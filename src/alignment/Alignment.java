package alignment;

import java.util.Collections;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Stream;

import genome.LinearGenome;
import genome.binary.BitGenome;
import util.IntPair;

/**
 * Represents an alignment between two {@link Genome}s.
 * The alignment itself is held as a sorted set of index pairs.
 * The Alignment also has an alignment score, and the two genomes it applies to.
 * @author adriaan
 */
public class Alignment<G extends LinearGenome<G>> extends VarOAlignment<G> {
    
	public final int score;
	
	public Alignment(int score, SortedSet<IntPair> pairs, G a, G b) {
		super(List.of(Collections.unmodifiableSortedSet(pairs)), a, b);
		this.score = score;
	}
	
	public int getScore() {
		return this.score;
	}
    
	@Override
    public String display() {
    	StringBuilder stra = new StringBuilder(),
    	              strb = new StringBuilder();
    	int ia = 0,
    	    ib = 0;
    	// Loop over matched pairs
    	for (IntPair i : this.getPairs()) {
    		// Print any gaps since last match (will usually be only on one side, but can be both, in which case genome a is printed first)
    		for (; ia<i.x; ia++) {
    			stra.append(this.getA().view1(ia));
    			strb.append('-');
    		}
    		for (; ib<i.y; ib++) {
    			stra.append('-');
    			strb.append(this.getB().view1(ib));
    		}
    		// Print match
    		stra.append(this.getA().view1(ia));
    		strb.append(this.getB().sameAt(ib, this.getA(), ia) ? '^' : this.getB().view1(ib));
    		ia++;
    		ib++;
    	}
    	// Print tails after last match
    	for (; ia < this.getA().size(); ia++) {
			stra.append(this.getA().view1(ia));
			strb.append('-');
    	}
    	for (; ib < this.getB().size(); ib++) {
			stra.append('-');
			strb.append(this.getB().view1(ib));
    	}
    	// Done
    	return stra.append("\n").append(strb).toString();
    }
	
	public static String splitLines(String alignment, int linelength, boolean[] displayIndex) {
		StringBuilder result = new StringBuilder();
    	String[] seqs = alignment.split("\n");
    	int len = Stream.of(seqs).mapToInt(String::length).max().orElse(0);
    	
    	int[] iNoGaps = new int[seqs.length];
    	int iWithGaps = 0;
    	
    	while (iWithGaps < len) {
	    	StringBuilder[] lines = new StringBuilder[seqs.length];
	    	
	    	for (int line=0; line<lines.length; line++) {
	    		lines[line] = new StringBuilder();
	    		if (displayIndex[line]) {
	    			lines[line].append(String.format("%5s: ", iNoGaps[line]));
	    		} else {
	    			lines[line].append("       ");
	    		}
	    	}
	    	
	    	do {
    		for (int line=0; line<lines.length; line++) {
    			if (iWithGaps < seqs[line].length()) {
    				char c = seqs[line].charAt(iWithGaps);
    				lines[line].append(c);
    				if (c != '-') iNoGaps[line]++;
    			}
    		}
    		iWithGaps++;
	    	} while (iWithGaps % linelength != 0);
	    	
	    	for (int line=0; line<lines.length; line++) {
	    		lines[line].append('\n');
	    		result.append(lines[line]);
	    	}
	    	
	    	result.append('\n');
    	}
    	
    	return result.toString();
	}
    
	@Override
    public String display(int linelength) {
    	return splitLines(this.display(), linelength, new boolean[] {true,true});
    }
    
    @Override
    public String toString() {
    	return this.display();
    }
    
    public static <G extends LinearGenome<G>> Alignment<G> empty(G a, G b) {
    	return new Alignment<>(0, Collections.emptySortedSet(), a, b);
    }
    
    public boolean isEmpty() {
    	return this.getPairs().isEmpty();
    }
    public boolean isNotEmpty() {
    	return !this.isEmpty();
    }
    
    /**
     * Collate a set of alignments, assuming an empty alignment of the provided genomes in case the given set is empty.
     * If the given set is known to be non-empty, use {@link #collateNonEmpty(Iterable)}.
     */
    public static <G extends LinearGenome<G>> Alignment<G> collate(Iterable<Alignment<G>> alignments, G a, G b) {
    	if (!alignments.iterator().hasNext()) {
    		return empty(a, b);
    	} else {
    		return collateNonEmpty(alignments);
    	}
    }
    
    // TODO Check if the provided alignments are non-crossing!
    /**
     * Combine partial (local) alignments into one, catenating the aligned pairs and summing the alignment score.
     * The given alignments must be non-overlapping, non-crossing (as in VarOAlignment) and affect the same genomes.
     * There is no requirement that the alignments must be generated by the same method.
     * @throws IllegalArgumentException - If the given set of alignments is empty, overlapping, or referring to different genome pairs.
     * @see #collate(Iterable, BitGenome, BitGenome)
     */
    public static <G extends LinearGenome<G>> Alignment<G> collateNonEmpty(Iterable<Alignment<G>> alignments) {
    	if (!alignments.iterator().hasNext()) throw new IllegalArgumentException("Cannot collate zero alignments.");
    	
    	SortedSet<IntPair> mypairs = new TreeSet<>();
    	int score = 0;
    	G a = null;
    	G b = null;
    	for (Alignment<G> alignment : alignments) {
    		if (a == null) a = alignment.getA(); else if (!a.equals(alignment.getA())) throw new IllegalArgumentException("Cannot collate alignments of different genomes.");
    		if (b == null) b = alignment.getB(); else if (!b.equals(alignment.getB())) throw new IllegalArgumentException("Cannot collate alignments of different genomes.");
    		
    		mypairs.addAll(alignment.getPairs());
    		score += alignment.score;
    		a = alignment.getA();
    		b = alignment.getB();
    	}
    	
    	return new Alignment<>(score, mypairs, a, b);
    }
    
}
