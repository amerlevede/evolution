package crossover.score;

import java.util.OptionalDouble;
import java.util.function.Function;

import crossover.CrossoverRule;
import mutation.MutationRule;
import util.Assert;

/**
 * Homology score.
 * Use: HomologyScore::score is a {@link CrossoverScore}.
 */
public final class HomologyScore {

	private HomologyScore() {
		Assert.utilityClass();
	}

	/**
	 * Calculate the homology score of a specific instance of crossover.
	 * Assumes the parents have homology information referring to the bits of the ancestor, and that the offspring were generated by performing a crossover (without mutation) from the parents.
	 *
	 * @param ancestor - The original ancestor of the two parents (not strictly necessary but makes calculation easier).
	 * @param p1 - Parent 1
	 * @param p2 - Parent 2
	 * @param c1 - Offspring (child) 1
	 * @param c2 - Offspring (child) 2
	 * @return Homology score.
	 * @see #homology(CrossoverRule, MutationRule, Function)
	 */
	public static OptionalDouble score(CrossoverOutcome crossover) {

		// Loop over homologous families
		// Instead of ancestor could also loop over union of homology ids on the parents or offspring
		int possiblePairs = 0;
		int homologouslyCrossedPairs = 0;
		for (long family : crossover.ancestor.uniqueIds().toArray()) {

			long numOfHomologsOnP1 = crossover.parentA.homologs(family).count();
			long numOfHomologsOnP2 = crossover.parentB.homologs(family).count();
			long numOfHomologsOnC1 = crossover.offspringA.homologs(family).count();
			long numOfHomologsOnC2 = crossover.offspringB.homologs(family).count();

			possiblePairs +=
					Math.min(numOfHomologsOnP1, numOfHomologsOnP2);
			homologouslyCrossedPairs +=
					Math.min(Math.min(numOfHomologsOnC1, numOfHomologsOnC2), possiblePairs);
		}

		return possiblePairs == 0
				? OptionalDouble.empty()
				: OptionalDouble.of(((double)homologouslyCrossedPairs) / ((double)possiblePairs));

	}



}
